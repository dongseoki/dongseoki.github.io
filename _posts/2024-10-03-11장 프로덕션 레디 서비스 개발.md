---
title: 11장 프로덕션 레디 서비스 개발
date: 2024-10-03 12:00:00 +0900
categories: [Software Development, Software Design]
tags: [MSA, 마이크로서비스 패턴 크리스 리처드슨] # TAG names should always be lowercase
---

# 목차

```
11장 프로덕션 레디 서비스 개발
11.1 보안 서비스 개발
__11.1.1 기존 모놀리식 애플리케이션의 보안
__11.1.2 마이크로서비스 아키텍처에서의 보안 구현
11.2 구성 가능한 서비스 설계
__11.2.1 푸시 기반의 외부화 구성
__11.2.2 풀 기반의 외부화 구성
11.3 관측 가능한 서비스 설계
__11.3.1 헬스 체크 API 패턴
__11.3.2 로그 수집 패턴
__11.3.3 분산 추적 패턴
__11.3.4 애플리케이션 지표 패턴
__11.3.5 예외 추적 패턴
__11.3.6 감사 로깅 패턴
11.4 서비스 개발: 마이크로서비스 섀시 패턴
__11.4.1 마이크로서비스 섀시
__11.4.2 이제는 서비스 메시로
11.5 마치며
```

# 정리 전략?

- 전부 정리는 NO
- 핵심중에서 꼭 적고 가야겠다 싶은 것만!
- 나의 생각을 섞어서 적을것..!
- 떠오르는 것 먼저 간단하게..!

# 내용

## 11.1 보안 서비스 개발

- 보안서비스를 개발할때 요새는 Oauth2.0의 프로토콜로 개발하여 서비스하는 편임.
- 애플리케이션 개발자는 주로 다음 네가지의 보안 요소를 구현한다.
  - 인증 : 애플리케이션에 접근하는 애플리케이션이나 사람의 신원을 체크한다. 일반적으로 인증키나 로그인 계정과 비밀번호를 사용한다.
  - 인가 : 어떤 주체가 요청을 보내왔을 경우 해당 요청을 수행할 수 있는 권한이 있는지 체크 한다.일반적으로 역할기반 (ROLE)  이나 접근제어리스트(ACL Access Control List) 를 함께 사용한다.
  - 감사 : 보안이슈탐지, 컴플라이언스 시행 등, 고객지원을 위해 주체가 수행하는 작업을 추적한다.
  - 보안 IPC : 드나드는 모든 요청은 TLS 를 경유 하도록 한다.
    출처: https://freeend.tistory.com/116 [FreeEnd:티스토리]

### \_\_11.1.1 기존 모놀리식 애플리케이션의 보안

- 세션 기반으로 로그인 상태를 유지, 관리하고, 인증, 인가 관리를 했었음.
- 기존 모놀리식 애플리케이션에서 사용자의 인증은 ID/패스워드 방식으로 진행한다. 사용자(클라이언트)가 ID/패스워드를 애플리케이션에 POST 로 요청한다. 애플리케이션은 요청온 자격증명이 맞으면 클라이언트에게 세션토큰을 반환한다. 세션 토큰을 받은 클라이언트는, 다음 요청서부터 세션 토큰을 포함시켜 서버로 전송시킨다. 애플리케이션은 이 HttpSession 객체를 메모리에 보관 해두고 있다가, 클라이언트의 요청에 포함되어있는 session tocken 를 식별해 인증한다.  
   보안 컨텍스트(Security Context) 는 인증된 정보를 저장하는 것을 말한다. 애플리케이션은 현재 요청을 보내온 사용자 정보 인증 정보를 ThreadLocal 을 이용해 정적 영역에 저장한다. 이러면 요청 내에서 언제든지 사용자의 정보를 불러내 확인할 수 있다.

![](assets/img/posts/2024-10-03-12-44-03.png)

### \_\_11.1.2 마이크로서비스 아키텍처에서의 보안 구현

- msa 방식에서 세션 방식의 인증 인가는 별로라는 내용을 이야기한듯.
  - 별로인 이유? : 세션 값이 서로다른 서비스에서도 인식 및 확인 가능할 정도여야 하면, 별도의 저장 관리가 필요함. 글로벌 저장소.
  - 그들 사이의 접속을 관리하는 것도 이슈임.
- 구성 가능한 서비스를 설계하려면 oauth2.0에 나오는 그것을 참고하여 구현을 해보자.
  - 인증 서버
  - 리소스 서버
  - 사용자
  - 하나는 뭐더라?

### 어려운 이유..

- 인-메모리 보안 컨텍스트 (in-memory security context) : Threadlocal 등을 인-메모리 보안컨텍스트를 이용해 사용자의 신원을 전달하는 방법이 있으나, 마이크로 서비스에서는 메모리가 공유되지 않으므로 사용할 수 없다.
  중앙화 세션 (centralized session) : 인-메모리 세션도 보안컨텍스트와 마찬가지로 사용할 수 없다. 우회적으로 마이크로서비스의 느슨한 결합 원칙에 위배되지만, DB에 세션정보를 넣고 각 서비스가 동일하게 접근할 수도 있다.

### API 게이트웨이에서 인증 처리

인증을 처리하는 방법은 여러가지나, 개별 서비스에서 인증을 구현할 경우 다음과 같은 문제가 생긴다.
모든 개발자가 제대로 보안을 개발 하리라는 보장이 없기때문에 보안적 취약점이 발생 될 수 있다. 이로인해 미인증 요청이 발생할 수 있다. 또, 클라이언트가 매번 자격증명을 전송한다던지, 애플리케이션이 매번 신규토큰을 생성 할 수 도 있다.
 때문에 가장 이상적인 방법은 API 게이트웨이를 이용하는 방식이다. 인증에 문제가 생기면 API 게이트웨이만 바로잡으면 되고, 개별 서비스에서 구현하는 로직을 게이트웨이에만 작성하면 된다. 
 API 게이트웨이로부터 호출받은 서비스는 게이트웨이로부터 받은 토큰으로 요청을 한번더 검증한다.

### 인가처리 -> 서비스에서 하자!

가작업은 클라이언트가 요청한 작업이 권한이 있는지 검사하는 작업이다. 
이 작업역시 API 게이트웨이에서 구현 가능하다. 권한이 없는 요청 인입시 라우팅 전에 거부하면 그만이다. 
하지만 API 게이트웨이에 인가로직을 두면 URL 등을 게이트웨이가 직접 챙겨야 하므로 게이트웨이와 서비스가 강한 결합이 발생 하게 된다. 
 따라서 인가로직은 서비스에 구현하는 편이 낫다. 서비스가 역할기반으로 URL 과 METHOD를 인가하고, ACL로 애그리거트 접근을 따로 관리한다.

### JWT로 사용자 신원/역할 전달

난독화 토큰 (opaque token) : 일반적으로 UUID (Universally Unique Identifier) 를 많이 사용한다. 단, 성능 및 가용성이 떨어지고, 지연시간이 길다.
투명 토큰 (transparent token) : JWT (Json Web Token) 이 사실상 표준이다. 두 당사자간의 신원/역할등 정보를 안전하게 보관 가능하다. JWT 는 인증정보, 토큰의 만료일자 등이 담긴 JSON 객체를 payload 에 담아 JWT 생성자(게이트웨이) 와 수신자 (서비스) 만  알수있는 코드로 암호화한다. 위변조가 불가능해 보안성이 강력하다. 그러나, JWT 에 토큰이 포함되어 있으므로 취소가 불가능해 토큰이 유출 될 경우 문제가 발생한다. 때문에 유효기간을 가능한 짧게 생성해 유출된 토큰의 오용을 막는다. -> 뒤에 리프시토큰과 혼용하여 강화 가능.

### OAuth 2.0 응용

- OAuth 2.0 의 핵심 개념은 다음과 같다.

  - 인증서버 (Authorization Server) : 사용자 인증 및 액세스/리프레시 토큰 획득 API 를 제공한다.
  - 액세스 토큰 (Access Token ) : 서비스 접근을 허가하는 토큰이다.
  - 리프레시 토큰 (Refresh Token) : 클라이언트가 새 액세스 토큰을 얻기 위해 필요한 토큰이다.
  - 리소스 서버 (Resource Server) : 액세스 토큰으로 접근을 허가하는 서비스. 곧 마이크로서비스를 제공하는 서비스를 말한다.
  - 클라이언트 : 리소스서버에 접근하려는 클라이언트. ** 마이크로 서비스 아키텍처 에서는 API 게이트 웨이가 이 클라이언트이다! **

- 액세스 토큰이 이미 거의 만료된경우, ** API 게이트웨이 ** 는 인증서버에 OAuth2.0 리프래시 승인을 요청해서 액세스 토큰을 새로 발급받습니다.
- OAuth2.0은 널리 검증된 보안 표준이다!

## 11.2 구성 가능한 서비스 설계

- 구성을 application.yaml과 같은 것으로 구성하는것은 보안 이슈가 있고, 그렇다고 빼고 따로 하자니 관리가 안됨.
- 구성을 외부에서 구성해서 가져오자!

### \_\_11.2.1 푸시 기반의 외부화 구성

- 푸시 기반으로

### \_\_11.2.2 풀 기반의 외부화 구성

- 풀 기반을 많이 씀.
- 이때 많이 쓰는게 스프링 클라우드 라는 것임.

## 11.3 관측 가능한 서비스 설계

- 어플리케이션을 운영하려면, 다양한 지표들을 보고 징후를 판단하고 조치할수 있어야함.
- 그런데 그게 안된다면, 어찌 해야하는가?

### \_\_11.3.1 헬스 체크 API 패턴

- 헬스 체크 api를 구현했다면, 해당 api만 호출하면 정상 상태인지 파악이 가능해야함.
- 스프링 액추에이터를 이용하면 쉽게 기능 구현가능.

### \_\_11.3.2 로그 수집 패턴

- 로그 수집의 경우 하나의 공간으로 모으는 편
- ELK를 주로 쓴다.
- fluentD도 쓰는 편이긴 함.

### \_\_11.3.3 분산 추적 패턴

- 분산 추적.
- 이 요청이 어디를 타고, 어디를 갔다가, 어디서 얼마나 걸렸고, 완료까지는 결국 몇초!
- ## 이런 정보의 관리를 하는 시스템 고려 필요.

### \_\_11.3.4 애플리케이션 지표 패턴

- 애플리케이션의
  - 비즈니스적 지표
  - 성능 지표
  - 를 관리할 수 있어야한다.
- 지표들은?
  - 여기 지표들은 스프링 엑추에이터에서 지원하는 매트릭을 이용하면 쉽게 구현할 수 있음.

### \_\_11.3.5 예외 추적 패턴

- 애플리케이션의 예외를 추적하는 패턴도 있음.
- 예외만 따로 관리하자!
- 센트리라는 것을 많이 쓰더라.

### \_\_11.3.6 감사 로깅 패턴

- 감사 로깅이란 : 수행동작과 진행과정을 일일이 기록하는 것.
- 주로 방법..? :
  - 메서드 호출 로깅 : 스프링 aop기능을 활용하여 가ㅡ능.
  - 이벤트 소싱 방식 : 애그리거트의 변경 이벤트를 전부 기록.
    - 쿼리는 따로 로깅해야한다는 것! 참고하자.

## 11.4 서비스 개발: 마이크로서비스 섀시 패턴

-

### \_\_11.4.1 마이크로서비스 섀시

### \_\_11.4.2 이제는 서비스 메시로

## 11.5 마치며

# 참고자료

- https://freeend.tistory.com/116
- https://velog.io/@litien/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%8C%A8%ED%84%B4-%ED%94%84%EB%A1%9C%EB%8D%95%EC%85%98-%EB%A0%88%EB%94%94-%EC%84%9C%EB%B9%84%EC%8A%A4-%EA%B0%9C%EB%B0%9C
