---
title: 10장 마이크로서비스 테스트 2부
date: 2024-09-30 20:00:00 +0900
categories: [Software Development, Software Design]
tags: [MSA, 마이크로서비스 패턴 크리스 리처드슨] # TAG names should always be lowercase
---

# 목차

```
10장 마이크로서비스 테스트 2부
10.1 통합 테스트 작성#
__10.1.1 통합 테스트: 영속화#
__10.1.2 통합 테스트: REST 요청/응답형 상호 작용#
__10.1.3 통합 테스트: 발행/구독 스타일 상호 작용#
__10.1.4 통합 계약 테스트: 비동기 요청/응답 상호 작용
10.2 컴포넌트 테스트 개발#
__10.2.1 인수 테스트 정의#
__10.2.2 인수 테스트 작성: 거킨#
__10.2.3 컴포넌트 테스트 설계#
__10.2.4 컴포넌트 테스트 작성: 주문 서비스
10.3 종단 간 테스트 작성#
__10.3.1 종단 간 테스트 설계#
__10.3.2 종단 간 테스트 작성#
__10.3.3 종단 간 테스트 실행
10.4 마치며
```

# 정리 전략?

- 전부 정리는 NO
- 핵심중에서 꼭 적고 가야겠다 싶은 것만!
- 나의 생각을 섞어서 적을것..!
- 떠오르는 것 먼저 간단하게..!

# 내용

## 10.1 통합 테스트 작성

1. 각 서비스의 어댑터 테스트
   예를 들어 JPA 영속화 테스트는 정확히 저장되었는지 OrderRepository를 직접 테스트한다.

2. 9장에서 나온 계약 활용
   ![](assets/img/posts/2024-09-30-21-06-33.png)
   계약의 용도는 컨슈머/프로바이더 둘 다 테스트해서 서로 바라보는 API가 일치하는가 확인하는 것, 테스트 대상이 컨슈머인지 프로바이더인지에 따라 다르다.

소비자 쪽 테스트: 계약을 이용해 프로바이더를 모킹한 스텁을 구성할 수 있어 프로바이더 실행 필요 없음
프로바이더 쪽 테스트: 디펜던시를 목으로 잡아 놓고 계약을 이용해 어댑터 테스트

### \_\_10.1.1 통합 테스트: 영속화

- 통합 테스트는 영속화 테스트를 포함한다.
- 레포지토리 단을 테스트해서 DB영속화가 성공적인지 테스트해보자.

### \_\_10.1.2 통합 테스트: REST 요청/응답형 상호 작용

- REST 요청과 응답이 정상적인지 테스트 하는 방법도 있다.
- 그것은 바로 mockMvc라는 것을 이용하는 것이다.
- REST 요청/응답형은 REST 끝점 및 요청/응답 본문의 구조에 대한 테스트를 해야한다.
  ![](assets/img/posts/2024-09-30-21-09-58.png)

1.  계약 생성
    ![](assets/img/posts/2024-09-30-21-11-58.png)

2.  HTTP Base

        when(orderRepository.findById(OrderDetailsMother.ORDER_ID)).thenReturn(Optional.of(OrderDetailsMother.CHICKEN_VINDALOO_ORDER));
        RestAssuredMockMvc.standaloneSetup(controllers(orderController));

    위와 같이 계약에 지정된 orderId로 원하는 Order를 반환하도록 구성한다.

3.  클라이언트 테스트

OrderServiceProxy 가 와이어목 포트에 요청하도록 구성한다. 그리고 각 테스트 메서드는 orderServiceProxy 를 호출해 정확한 값이 반환되는지, 기대한 예외가 던져지는지 확인한다.

#### WireMock?

마이크로서비스 아키텍처에서 "와이어 목(Wire Mock)"은 의류 디자인의 개념과는 다르게 테스트를 위한 도구로 사용됩니다. 정확한 명칭은 **WireMock**이며, 이는 마이크로서비스 패턴 및 테스트에서 다음과 같은 의미를 가집니다.

##### WireMock이란?

**WireMock**은 Java 기반의 HTTP Mock 서버 라이브러리로, 개발자들이 외부 API 호출을 테스트할 때 실제 API 서버를 호출하는 대신, 가상의 API 서버를 만들어 HTTP 요청과 응답을 미리 정의할 수 있게 해주는 도구입니다. 이를 통해 서비스 간의 의존성을 낮추고, 마이크로서비스 간의 통신을 시뮬레이션할 수 있습니다.

##### WireMock의 주요 기능

1. **가짜 HTTP 서버(Mock HTTP Server)**: WireMock은 테스트를 위해 실제 API 서버 대신 사용할 수 있는 가짜 HTTP 서버를 생성합니다. 이 서버는 HTTP 요청을 받고, 사전에 정의된 응답을 반환합니다.

2. **HTTP 요청/응답 시뮬레이션**: WireMock을 사용하면 특정 HTTP 요청에 대해 어떤 응답을 줄지 미리 설정할 수 있습니다. 이를 통해 외부 API가 반환할 값을 예측하고, 다양한 상황을 테스트할 수 있습니다.

3. **상태 기반의 테스트(Stateful Behavior)**: 특정 조건에 따라 응답이 달라지도록 상태 기반 테스트를 지원합니다. 예를 들어, 특정 API 호출이 성공한 후에 다른 호출의 응답이 변경되는 등 복잡한 시나리오를 구현할 수 있습니다.

4. **네트워크 오류 시뮬레이션**: 네트워크 지연, 타임아웃, 연결 실패 등의 상황을 시뮬레이션하여 서비스의 오류 처리 능력을 테스트할 수 있습니다.

##### WireMock을 사용하는 이유

마이크로서비스 환경에서는 각 서비스가 독립적으로 개발되지만 서로 간의 API 통신이 필수적입니다. 만약 다른 서비스나 API 서버가 준비되지 않았거나, 타임아웃, 오류 등의 상황을 테스트해야 한다면, 실제 API를 호출하는 것은 어렵거나 비효율적일 수 있습니다. WireMock을 사용하면 이러한 제약 없이:

- 외부 서비스의 응답을 가정하여 독립적인 테스트를 수행할 수 있고,
- 타임아웃, 예외 상황, 잘못된 응답 등 다양한 케이스를 쉽게 재현할 수 있습니다.

##### WireMock 사용 예시

1. 특정 API 요청이 성공적인 응답을 받을 때:
   ```java
   stubFor(get(urlEqualTo("/user/123"))
       .willReturn(aResponse()
           .withStatus(200)
           .withBody("{ \"id\": \"123\", \"name\": \"Alice\" }")));
   ```
2. 특정 요청에 대해 오류를 반환하도록 설정:

   ```java
   stubFor(get(urlEqualTo("/user/123"))
       .willReturn(aResponse()
           .withStatus(500)
           .withBody("{ \"error\": \"Internal Server Error\" }")));
   ```

3. 응답 지연 시뮬레이션:
   ```java
   stubFor(get(urlEqualTo("/user/123"))
       .willReturn(aResponse()
           .withStatus(200)
           .withFixedDelay(3000)  // 3초 지연
           .withBody("{ \"id\": \"123\", \"name\": \"Alice\" }")));
   ```

##### 결론

따라서 마이크로서비스 패턴에서의 WireMock은 외부 API와의 통신을 시뮬레이션하고 테스트 환경을 쉽게 구축할 수 있게 도와주는 **HTTP Mock 서버 도구**입니다. 이를 활용하여 서비스 간의 의존성을 줄이고, 다양한 상황에 대한 테스트를 보다 효율적으로 수행할 수 있습니다.

### \_\_10.1.3 통합 테스트: 발행/구독 스타일 상호 작용

- 발행 구독 스타일을 상호 작용은 중간에 contract계약서를 두고 테스트 할 수 있다.
  - 발행은 발행한 내용이 contract에 의거한 대로 발행된 것인지 확인한다.
  - 구독은 contract에 의거한 이벤트 발생시, 의도한대로 상호작용이나 행위가 일어나는지 확인한다.
- 발행/구독 스타일은 서로가 바라보는 메시지 채널 & 도메인 이벤트 구조가 서로 일치하는지 확인해야 한다.
  ![](assets/img/posts/2024-09-30-21-17-00.png)

### \_\_10.1.4 통합 계약 테스트: 비동기 요청/응답 상호 작용

- 서비스의 메시징 프록시를 호출해 메시징 프록시가 계약대로 커맨드 메시지를 보내는지, 그리고 프록시가 응답 메시지를 적절히 처리하는지 확인
- 비동기 요청 응답 상호 작용도 contract를 이용하여 유사하게 이루어진다.
  ![](assets/img/posts/2024-09-30-21-19-04.png)

### 결국 통합테스트는.

- 통합 단위 테스트는 서비스의 개별 부분의 동작을 확인합니다. 통합 테스트는 서비스가 자신의 클라이언트/디펜던시와 올바르게 소통하는지, 단위 테스트는 서비스 로직이 정확한지 확인합니다. 하지만 이 두 테스트는 전체 서비스를 실행하지는 않습니다. 전체 서비스가 잘 작동되는지 확인하려면 피라미드를 한 단계 올라가 컴포넌트 테스트를 작성해야 합니다.

## 10.2 컴포넌트 테스트 개발

### \_\_10.2.1 인수 테스트 정의

- 인수 테스트와 컴포넌트 테스트 차이가 잘 떠오르지 않았다.

### \_\_10.2.2 인수 테스트 작성: 거킨

-

### \_\_10.2.3 컴포넌트 테스트 설계

- 여기서 말하는 컴포넌트는 하나의 사용자 상호작용을 테스트 한다고 볼 수 있다.
- 예를 들면, 승인된 사용자가 주문을하게 되면, 해당 주문은 승인된다.
- 가정 -> 예상 결과.

### \_\_10.2.4 컴포넌트 테스트 작성: 주문 서비스

## 10.3 종단 간 테스트 작성

### \_\_10.3.1 종단 간 테스트 설계

- 종단간 테스트는 사용자의 다양한 상호작용을 테스트하는 방식이다.

### \_\_10.3.2 종단 간 테스트 작성

### \_\_10.3.3 종단 간 테스트 실행

## 10.4 마치며

# 참고자료

https://velog.io/@jimin3263/MSA-10.-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8-2%EB%B6%80

- https://www.amazon.com/Microservices-Patterns-examples-Chris-Richardson/dp/1617294543
- https://livebook.manning.com/book/microservices-patterns/table-of-contents/1
- https://medium.com/@onurbaskirt/microservices-testing-strategies-part-2-d6e460145136
