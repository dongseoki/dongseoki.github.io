---
title: 5주2일차_페이징처리및회적화사례실습
date: 2025-01-20 12:05:00 +0900
categories: [Software Development]
tags: [] # TAG names should always be lowercase
---

## 필기 가자
### **2.1 OFFSET이 큰 경우 성능 저하 발생 이유**

- **문제 발생 원리**:
    - 데이터베이스는 OFFSET에 지정된 값만큼 데이터를 건너뛰기 위해 결과 집합을 메모리에 로드하고, 해당 범위의 데이터를 모두 스캔(Discard)합니다.
    - OFFSET의 값이 커질수록 건너뛰어야 하는 데이터가 많아지고, 이로 인해 쿼리 처리 시간이 급격히 증가합니다.

- 소규모 데이터베이스에서는 OFFSET 기반 페이징을 사용할 수 있지만, 대규모 데이터베이스에서는 성능 최적화가 필요합니다.
- 이를 해결하기 위해 **Keyset Pagination** 또는 **인덱스를 활용한 최적화 전략**을 도입해야 합니다.

### **3.1 Keyset Pagination (커서 기반 페이징)**

- **Keyset Pagination**은 OFFSET을 사용하지 않고, 이전 요청의 마지막 데이터 값을 기준으로 다음 데이터를 가져오는 방식입니다.
- **작동 방식**:
    - 특정 정렬 기준(Key)을 사용하여 이전 요청의 마지막 데이터를 기준으로 이후 데이터를 가져옵니다.
    - OFFSET이 필요하지 않아 불필요한 데이터 스캔을 방지.
- **장점**:
    - 대규모 데이터에서도 일정한 성능 유지.
    - 고정된 Key를 기반으로 필요한 데이터만 조회 가능.
- **단점**:
    - 정렬 기준(Key) 설정이 복잡할 수 있으며, 페이지 번호 기반 탐색이 어려움.

**복합 인덱스**:

- `category_id`와 `created_at`에 대한 복합 인덱스를 생성하면, 검색 조건 (`WHERE`)과 정렬 조건 (`ORDER BY`)을 인덱스가 모두 활용할 수 있습니다.
- 이를 통해 **테이블 스캔** 대신 **인덱스 범위 스캔**으로 검색 성능이 향상됩니다.

- **OFFSET/LIMIT** 방식은 간단하지만 대량 데이터에서는 비효율적입니다.
- **Keyset Pagination**은 일정한 성능으로 안정적인 페이징을 제공하며 대규모 데이터에 적합합니다

## Action Plan


## 수업 내용 필기 정리.
- 이거는 수업 내용을 자세히 들으면 도움이 될듯.
